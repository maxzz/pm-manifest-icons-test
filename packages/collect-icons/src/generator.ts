/**
 * Generate the collected icons TypeScript file and write it to disk.
 *
 * @param groups - Mapping of import path -> exported symbol names. Example: { 'app/components/ui/icon': ['SvgSymbolFoo','SymbolFoo'] }
 * @param uniqueNames - Deduplicated, sorted list of all collected names. Example: ['SvgSymbolFoo','SymbolFoo']
 *
 * @returns Promise resolving to an object { dest, names } where `names` is the list of collected names.
 */
export async function generateCollectedFile({ groups, uniqueNames }: { groups: Record<string, string[]>; uniqueNames: string[]; }): Promise<string> {
    const lines: string[] = [];
    lines.push(...generateFileHeader());

    // 1. imports
    for (const [importPath, componentNames] of Object.entries(groups)) {
        const unique = Array.from(new Set(componentNames)).sort();
        unique.length && lines.push(`import { ${unique.join(', ')} } from '${importPath}';`);
    }
    lines.push('');

    // 2. export a single object containing all collected components
    // Annotate each entry with a comment showing where it was imported from (first occurrence)
    const nameToImport = new Map<string, string>();
    for (const [importPath, componentNames] of Object.entries(groups)) {
        for (const n of componentNames) {
            if (!nameToImport.has(n)) {
                nameToImport.set(n, importPath);
            }
        }
    }

    if (uniqueNames.length > 0) {
        const commonPath = findCommonPathInUniqueNames(Object.keys(groups));

        lines.push('export const collectedIconComponents = [');
        // compute max name length so comments can be aligned
        const maxNameLen = uniqueNames.reduce((m, s) => Math.max(m, s.length), 0) + 4; // 4 for the space after the name and comma

        for (const componentName of uniqueNames) {
            const from = nameToImport.get(componentName);
            if (from) {
                const padding = ' '.repeat(Math.max(1, maxNameLen - componentName.length)); // name, then padding so all comments line up vertically
                // lines.push(`    ${componentName},${padding}// from '${from}'`);

                const short = from.replace(commonPath, '').replace(/^\//, '');
                lines.push(`    { component: ${componentName},${padding} path: '${short}' },`);
            } else {
                lines.push(`    ${componentName},`);
            }
        }
        lines.push('];');
        lines.push('');
    } else {
        lines.push('export const collectedIconComponents = {};\n');
    }

    // 2. names array and type
    lines.push(`export const collectedIconNames = [\n    ${uniqueNames.map(n => `'${n}'`).join(',\n    ')},\n] as const;\n`);
    lines.push('export type CollectedIconType = typeof collectedIconNames[number];');

    const rv = lines.join('\n');
    return rv;
}

function generateFileHeader(): string[] {
    return [
        '// Auto-generated by vite-plugin-collect-icons. Do not edit.',
        '/* eslint-disable */',
        ''
    ];
}

function findCommonPathInUniqueNames(uniqueNames: string[]): string {
    if (!uniqueNames || uniqueNames.length === 0) return '';

    // normalize separators and split into parts
    const partsList = uniqueNames.map(p => p.replace(/\\/g, '/').split('/'));
    const minLen = Math.min(...partsList.map(parts => parts.length));

    const commonParts: string[] = [];
    for (let i = 0; i < minLen; i++) {
        const segment = partsList[0][i];
        if (partsList.every(parts => parts[i] === segment)) {
            commonParts.push(segment);
        } else {
            break;
        }
    }

    return commonParts.join('/');
}

//TODO: add exort root or extract root from comments
//TODO: instead of comment add this as second member of each component name
//TODO: app: show folder name if there are multiple
